---
title: "Automatization_in_R"
author: "AR"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
library(tidyverse)
```

# 1. Установка R и полезные источники

## 1.1 Установка языка R и окружения

Что такое R?

```         
R — язык программирования, предназначенный для статистической обработки данных. 
```

Конечно, с его помощью можно сделать и сайт, и калькулятор, но основное
предназначение языка заключается именно в статистических расчётах и
моделировании.

Также R представляет собой свободную программную среду с открытым
исходным кодом, которая распространяется абсолютно свободно и имеет
бесчисленное количество обучающих и поясняющих материалов. R доступен
для практически всех существующих операционных систем: Windows, Linux,
macOS, и других.

Основное представительство R в сети --- сайт r-project.org (к нему мы
вернёмся в следующих уроках), на котором пользователи могут не только
установить самые последние обновления, но и изучить почти 11.000
пакетов, доступных для свободной загрузки и в большинстве своём
снабжённых достаточно подробной документацией.

Для того, чтобы начать его использовать, R доступен для работы в
командной строке используемой пользователем ОС или с помощью
стандартного GUI, однако наиболее используемым и обладающим наиболее
удобным интерфейсом многими считается RStudio (осторожно, это не
программа для восстановления файлов).

Важное примечание: все названия папок, в которые мы собираемся
устанавливать R, должны иметь названия на латинице, не содержать
пробелов. Лучше, если будут только латиница и нижние подчёркивания. Чаще
всего проблема возникает с именем пользователя: проверьте, соответствует
ли оно рекомендациям.

```         
C:\Users\user_name\OneDrive\my_jobs\project 
project_name    project-name
username\OneDrive\myjobs\project
```

###### Для установки R необходимо:

```         
Перейти на сайт R возможно по следующей ссылке: https://cran.r-project.org;
Выбрать установленную на компьютере операционную систему и нажать на неё:
Скорее всего, это наша первая установка R, поэтому нажимаем на “install R for the first time” - в результате скачается полная базовая сборка R:
```

После этих процедур у нас будет установленный R, но доступ к нему пока
что возможен исключительно через командную строку или GUI, что чаще
всего решительно неудобно.

###### Установка RTools

Давайте, установим инструменты Rtools с того же сайта, где мы скачивали
дистрибутив языка R.

Rtools --- это набор программ, необходимых в Windows для сборки пакетов
R из исходного кода.

Rtools могут пригодиться, когда мы будем работать с некоторыми пакетами
в ходе анализа, например, устанавливать их не из основного хранилища
CRAN. Алгоритм установки ничем не отличается от установки предыдущих
программ:

```         
Повторяем первые два шага из урока по установке R;
На третьем шаге выбираем RTools: 
Устанавливаем RTools так же, как и R.
```

###### Установка r-base-dev для Linux.

Если у вас Linux, то этот шаг для вас!

```         
1)  Установим r-base-dev:
sudo apt update
sudo apt install r-base-dev
2)  Готово!
```

###### Установка RStudio

У нас установлен R и все необходимые дополнительные пакеты. Но пока что
мы можем использовать R только через командную строку. Установим RStudio
для того, чтобы сделать анализ данных удобным и эффективным.

```         
Перейдём по ссылке на сайт https://www.rstudio.com/products/rstudio/download/ ;
Пролистаем вниз и увидим, что есть варианты установщиков для всех распространённых операционных систем
```

######Сопоставьте, зачем нужны указанные компоненты R - Язык
программирования, ориентированный на статистическую обработку данных
RStudio- Среда разработки, в которой удобно делать статистический анализ
Rtools- Дополнительные компоненты для установки пакетов R

## 1.2 Самостоятельный поиск ответов на частые вопросы

В ходе статистического анализа каждый раз возникают вопросы, не имеющие
быстрого решения. Даже если вы работаете (био)статистиком уже много лет,
эти вопросы возникают почти каждый день, хоть с годами их и становится
меньше.

Здесь мы изучим несколько способов, как искать ответы:

1.  Справка внутри R;

2.  drr.io;

3.  stackoverflow.com;

4.  Поиск ошибки в Google.

Справка внутри R

```         
1.    Знак вопроса (?) в сочетании с названием функции без скобок. Стоит сказать, что это работает только для уже подключённых пакетов. Например, в пакеты stats и base подключены сразу. Например: ?mean, ?sqrt, ?median:

2.    Два знака вопроса (??) в сочетании с названием функции, термином или фразой (на английском языке). Это возвращает справку о пакетах и функциях, подходящих под запрос
```

Поиск информации в Сети

Иногда нужно получить большее количество информации, чем даёт справка. В
таком случае мы идём в Интернет и ищем эту информацию. Рассмотрим
несколько полезных способов:

```         
Функция RSiteSearch() перенаправляет на search.r-project.org, где представлена информация по искомому термину. Обратите внимание, что термин должен быть заключён в кавычки. Пример: RSiteSearch("biostatistics")

Сайт rdrr.io, на котором можно найти почти то же самое, что и выше, но нужно напрямую искать: 

Сайт stackoverflow.com — это жемчужина поиска ответов на вопросы для статистиков/программистов и почти всех, кто связан с компьютерами. В отличие от предыдущих двух сайтов этот наполняется людьми, которые задают вопросы и дают на них ответы. Почти всегда можно найти ответ на свой вопрос и увидеть многочисленные варианты его решения: 
```

# 2. RStudio и создание проектов

## 2.1 Интерфейс RStudio

Что такое RStudio

RStudio --- это IDE (integrated development environment, интегрированная
среда разработки) для языка R.

В число её приятных особенностей входит бесплатность (для базовой
версии), открытый исходный код. Первое значит, что мы можем просто
скачать нужную нам версию без какой-либо оплаты, а второе --- что любой
может убедиться в том, что в коде программы нет посторонних уязвимостей
или скрытых функций.

RStudio существует в двух версиях:

```         
RStudio Desktop — версия для локальных машин, работает непосредственно на компьютере, на котором установлена;
RStudio Server — доступ через браузер к RStudio, установленной на удалённом сервере.
```

##### Разделы верхнего списка

RStudio существует для WIndows, LInux, OS X и написана на C++. В
интерфейсе программы рассмотрим именованные разделы в верхнем списке, а
именно те разделы, которые будем использовать часто.

###### **File**

**File** содержит в себе различные способы работы с файлами:

```         
New File повторяет функционал уже рассмотренной кнопки №1 в графическом меню;
New Project также создаёт новый проект;
Open File просто открывает файл;
Reopen with Encoding открывает файл заново с выбранной кодировкой. Полезно, когда вместо букв в файле видны странные нечитаемые символы — подбор правильной кодировки зачастую очень увлекательное занятие;
Open Project открывает существующий проект;
Open Project in New Session тоже открывает существующий проект, но делает это в новом окне RStudio. Полезно, когда нужно открыть сразу несколько проектов, чтобы изучать их одновременно;
Save сохраняет текущий файл;
Save As сохраняет текущий файл с выбором расширения и названия;
Save with Encoding позволяет сохранить файл с выбором кодировки. Полезно, когда нужно сохранить файл совсем не в той кодировке, в какой он был изначально;
Save All сохраняет все открытые в данный момент файлы;
Close закрывает текущий файл;
Close All закрывает сразу все файлы;
Close All Except Current закрывает все файлы, кроме того, в котором мы находимся в данный момент;
Close Project закрывает текущий проект;
Quit Session закрывает окно RStudio. Используйте с осторожностью.
```

###### **Edit**

**Edit** содержит в себе различные способы взаимодействия
непосредственно с пишущимся кодом:

```         
  Back и Forward позволяют листать положения курсора по истории его... положений;
Undo и Redo позволяют листать уже по изменениям: откатывать на одно изменение назад или возвращать одно изменение вперёд соответственно;
Cut, Copy, Paste повторяют известные горячие клавиши: Ctrl + X, Ctrl + C, Ctrl + V (вырезать, скопировать, вставить) соответственно;
Отдельно стоит поговорить про Find и группу функций, связанных с ней. Так как мы пишем текст, зачастую полезным оказывается искать слова (ведь они повторяются). С помощью Ctrl + F (или просто по нажатию кнопки Find) открывается окно, которое приведено ниже. В следующем шаге мы рассмотрим его подробнее.
```

##### Поиск и замена строк в коде

Часто бывает так, что уже написано несколько сотен строк кода, но
внезапно необходимо найти все вхождения названия функции, которую мы
применяли сто раз. Или даже изменить это название.

Разумеется, малоэффективно и попросту нудно сто раз менять название, к
тому же можно легко допустить ошибку и не заметить этого.

Здесь на помощь приходит find-replace. Вновь разберём основные элементы:

```         
Find — это поле, в которое вводится искомый паттерн из символов, или, простыми словами, искомое слово;
Replace — это поле, в которое вводится паттерн, на который заменяется паттерн из Find;
Next, Prev, All соответственно переключают на следующий искомый паттерн, предыдущий или выбирают все сразу;
Replace, All выбирают, производить ли замену только в одном случае или сразу во всех. При этом, если нажимать Replace раз за разом, то замена будет производиться для следующего паттерна;
In selection переключает поиск в режим "искать только в выделенном заранее сегменте", что позволяет не заменить нечаянно то, что не нужно. Также помогает найти слово в маленьком отрезке кода, когда разбегаются глаза и сложно найти, что было написано только что;
Match case говорит, учитывать регистр (большая буква или маленькая) или нет;
Whole word говорит, искать ли только слово целиком или включить в результат слова, внутри которых находится искомое слово;
Regex переключает поиск в режим регулярных выражений. Это потрясающий инструмент, позволяющий с помощью метасимволов искать и заменять не просто слова, а целые шаблоны.
```

Интересный факт: если мы хотим добавить к строке какую-то ещё строку,
например, ко всем "data" добавить "data_c1", нам достаточно заменить
строку "data" на строку "data_c1".

##### Окно консоли и терминала

Окно терминала нужно только в исключительных случаях, однако полезно
знать, что для того, чтобы выполнить некоторые специфические
манипуляции, не нужно открывать отдельно командную строку.

При написании кода, который должен создать статистический отчёт, каждый
раз возникает ситуация, в которой нужно проверить вывод куска кода здесь
и сейчас, или вывести датасет, в который мы будем периодически
подсматривать при создании функции. Или просто быстро посмотреть, что в
данный момент находится в переменной.

Именно для таких случаев пригождается консоль: проверять текущие
переменные, не загрязняя основной код и не забывая удалить в нём
проверочные вызовы данных и функций.

## 2.2 Projects в RStudio

Проекты в RStudio обладают несколькими существенными преимуществами,
серьёзно облегчающими работу с кодом:

Индивидуальная рабочая директория. Сравнимо с тем, как если бы мы
выполнили setwd() для папки каждый раз, когда начинаем работать. Рабочие
директории проектов не пересекаются, благодаря чему можно запускать
сразу несколько проектов одновременно. Крайне не рекомендуется изменять
название директории, если вы уже создали её, иначе все пути сломаются;
Относительные пути до файлов. Каждый раз, когда мы переносим папку
проекта, пути, которые мы прописываем в коде, начинаются от папки
проекта. В результате каждый раз, когда папка проекта переносится на
новый компьютер, можно не беспокоиться, что все файлы, которые
загружаются внутри кода, внезапно перестанут читаться; Переносимость.
Результат предыдущих двух преимуществ. Когда нужно передать код, данные,
в целом наработки коллегам, можно заархивировать папку проекта и просто
переслать по почте или иному файлообменнику; Дополнительно: когда
создаётся проект, можно автоматически сделать папку проекта ещё и
репозиторием git, что упрощает работу с контролем версий. Исходя из
этого, можно предположить, что проектами стоит пользоваться всякий раз,
когда мы начинаем новый... проект анализа данных.

Например, удобно объединить в единой директории протокол, план
статистического анализа, код статистического анализа, генерируемый
статистический отчёт. В итоге всё будет находиться в одном месте и можно
будет просто открыть проект и продолжить работать с места, на котором
остановились.

писание структуры папки проекта: RProject, RHistory, RData. Пример того,
как стоит организовывать иерархию папок.

Структура папки проекта

По умолчанию папка проекта после первого сохранения содержит:

rmd-файл, в котором эффективным образом организован код. Подробнее этот
тип файла мы разберём позже; .RData --- хранилище всех переменных. Его
содержание отображается в RStudio в окне Environment, которое мы
разбирали ранее. Забавной особенностью является то, что рано или поздно
(но скорее рано) этот файл становится настолько огромным, что либо
заполняет собой всю оставшуюся память компьютера в особо неудачном
случае или, в удачном, приводит к тому, что проект загружается долгие
минуты или не может быть загружен вообще; .RHistory --- хранилище всех
изменений кода. Если вы не хотите, чтобы кто-нибудь узнал о том, как
именно вы изменяли код до тех пор, пока он не стал написан чисто и
аккуратно, этот файл тоже можно периодически очищать. Также в нём можно
найти нечаянно удалённые куски нужного кода; .RProj --- этот файл
является тем файлом, что правит всеми остальными, а ещё это точка входа
в проект. Крайне не рекомендуется изменять его название (как и название
папки проекта); Прочие папки. Остановимся на них подробнее и приведём
рекомендуемый минимальный набор. Прежде всего, для чистоты проекта лучше
создавать папку data рядом с остальными вышеперечисленными файлами. Уже
в ней можно создать следующие папки:

*originals* --- сюда просто складываем все исходные файлы, нужные для
проекта. Важной особенностью этой папки должно являться то, что файлы в
ней мы ни в коем случае не меняем. Таким образом всегда останется
резервная чистая копия, если что-то пойдёт не так в других папках. Для
работы с файлами мы просто копируем файлы из этой папки в другие;

*pics* --- сюда сохраняем картинки/графики и прочую графическую
информацию, появляющуюся в ходе анализа;

*raw* --- сырые файлы данных. Именно из этой папки мы будем читать
данные и загружать их в R для последующего анализа. В ней так же не
стоит менять файлы, чтобы гарантировать, что все изменения, проводимые в
R, проводятся на основе тех же данных, что есть у коллег;

*documents* --- здесь лежит вся документация, такая как протоколы, SAPы
(планы статистического анализа), листы регистрации и подобное. Конечно,
описанная структура папок может изменяться, но, возможно, такая
организация может облегчить анализ данных и поиск документов/данных
спустя месяцы, когда проект уже выветрился из памяти

## 2.3 RMarkdown

RMarkdown позволяет соединить текст, визуализации и код, который будет
генерировать код и даже текст в отдельных случаях.

Документы RMarkdown (Rmd) полностью воспроизводимы. Это значит, что,
когда мы закончим документ, то любой аналитик сможет позже запустить
выполнение всего файла целиком и получить на выходе потрясающе
выглядящий и полностью информативный отчёт (в случае, если мы его таким
сделали).

.Rmd файл --- это просто текстовый файл с указанным расширением. Но, в
отличие от просто .R файла он содержит в себе чанки, позволяющие
организовывать код удобным способом. Далее мы рассмотрим всё, что нужно
знать про RMarkdown-файл, подробнее.

### Заголовок, чанки, простой текст

Файл состоит из трёх основных типов содержимого:

**1) Заголовок YAML**, окружённый ---, он не обязательно должен
присутствовать, но в нём можно указывать (ниже примеры):

Пример YAML-заголовка Заголовок : title: "Example title" ---
отображается в начале документа большим шрифтом; Подзаголовок: subtitle:
"Example subtitle" --- отображается под заголовком шрифтом поменьше;
Автор: author: "User Name"; Дата: date: "`r Sys.Date()`" --- в данном
примере дата будет обновляться при каждом выводе документа в печать;
Вывод: output: word_document --- в данном примере вывод настроен на
вывод документа формата .docx.

**2. Чанки**. Вставляются с помощью Ctrl + Alt + I или просто с помощью
написания `{r} в начале чанка и закрывающих` в конце чанка. Внутри мы
пишем код, вывод которого печатается после чанка. Этот же вывод появится
в итоговом документе:

Типичный чанк В фигурных скобках после указания r как используемого в
чанке языка можно через пробел указать название чанка, чтобы позже было
проще ориентироваться; Шестерёнка в правом верхнем углу позволяет
настраивать в графическом режиме параметры чанков, которые мы изучим в
следующих уроках; Кнопка в виде белого треугольника с зелёной полоской
выполнит все фрагменты кода выше данного текущего чанка. Также можно
сделать с помощью постановки курсора в чанк и горячих клавишей Ctrl +
Alt + P; Крайний правый зелёный треугольник просто выполнит весь код в
чанке.

**3. Простой текст.**

```         
*выделение* (например, курсив)
**сильное выделение** (например, полужирное начертание)
```

### **Программный код**

Элементы кода могут быть внутри строки (inline) либо многострочными
блоками.

Внутри строки код выделяется символом «\`» ([обратный
апостроф](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BE%D0%BF%D0%B8%D1%81%D0%BD%D1%8B%D0%B9_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D1%84 "Машинописный обратный апостроф")).

```         
Пример кода внутри строки (inline) `Hello world!`
```

Многострочный блок кода обозначается отступом из 4 пробелов или одного
[Tab](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F "Табуляция").

```         
Ниже начинается многострочный блок кода

    <!doctype html>
    <html>
        <head>
            <!-- Заголовок документа -->
        </head>
        <body>
            <!-- Тело документа -->
        </body>
    </html>

Блок кода завершился
```

### **Зачёркнутый текст**

```         
необходимо сделать ~~одну~~ другую вещь
```

### **Списки**

```         
* элемент маркированного списка
- ещё один элемент ненумерованного списка
+ буллеты элементов могут быть разными

1. Элемент нумерованного списка
2. Элемент №2 того же списка
9. Элемент №3 списка — элементы нумеруются по порядку, цифра в начале строки не имеет значения
```

### **Заголовки**

Создание заголовков производится путём помещения [знака
решетки](https://ru.wikipedia.org/wiki/%D0%9E%D0%BA%D1%82%D0%BE%D1%82%D0%BE%D1%80%D0%BF "Октоторп")
перед текстом заголовка. Количество знаков «#» соответствует уровню
заголовка. HTML предоставляет 6 уровней заголовков.

```         
# Заголовок первого уровня
...
### Заголовок третьего уровня
...
###### Заголовок шестого уровня
```

Первые два уровня заголовка также имеют альтернативный синтаксис:

```         
Заголовок первого уровня
========================

Заголовок второго уровня
------------------------
```

### **Цитаты (тег blockquote)**

```         
> Данный текст будет заключен в HTML-теги <blockquote></blockquote>
```

### **Ссылки**

```         
[Текст ссылки](http://example.com/ "Необязательный заголовок ссылки")
```

Альтернативный способ задавать ссылки, если есть повторения:

```         
Где-то среди текста встречается [текст ссылки][example].

Также ссылка повторяется [пример адреса][example].

Ссылка на [второй][foo] также [Bar][] ресурсы.

[example]: http://example.com/ "Необязательный заголовок ссылки"
[foo]: http://example.net/ 'Необязательный заголовок ссылки'
[bar]: http://example.edu/ (Необязательный заголовок ссылки)
```

### **Изображения**

```         
![Alt-текст](http://example.com/ "Заголовок изображения")
```

## **Первый чанк**

![](https://ucarecdn.com/5efee9b9-c998-40b3-a7a7-fb1f9b9e19e4/){alt=""}

В каждом rmd-файле есть первый чанк, что правит всеми остальными.

В нём находится `knitr::opts_chunck$set()`, в котором устанавливаются
общие параметры вывода чанков.

В нём же следует писать и код подключения пакетов, чтобы они
автоматически подключались, а также чтобы каждый новый человек, который
будет работать с кодом, мог сразу понять, какие пакеты будут
использоваться в анализе.

Сюда же можно рекомендовать класть и собственноручно написанные функции
с тем, чтобы они автоматически подгружались при запуске и чтобы не
случилось внезапно так, что функция используется раньше, чем будет
объявлена.

### **Настройки Rmd-файла**

Многие функции помимо выполнения основной цели добавляют в вывод
различные сообщения, а ещё могут выдавать предупреждения и даже ошибки.

Таже чаще всего тем, кто будет смотреть статистический отчёт, не нужен
код, который создаёт таблицы. Им нужны сами таблицы, а код можно
посмотреть в пересланном проекте. 

Именно для таких случаев, а также нескольких дополнительных нужны
настройки чанков. Обычно самые критичные стоит устанавливать в первом
чанке, а именно в функции, которая по умолчанию появляется в нём, когда
создаётся rmd-файл:

![](https://ucarecdn.com/07c78438-08d5-484b-bba0-5714bed82bf3/){alt=""}

Изучим список основных функций. Значения по умолчанию сразу будут
приведены вместе с названием:

1.   `echo = TRUE` --- показывать ли код при печати документа. Обычно
    это не нужно, поэтому есть смысл установить `FALSE`;

2.  `error = FALSE` --- показывать ли при печати ошибки;

3.  `eval = TRUE` --- выполнять ли код в чанке. Обычно мы действительно
    хотим, чтобы код в чанке выполнялся, однако иногда есть смысл
    временно или навсегда выключить один или несколько чанков из кода. В
    таком случае этот чанк на всякий случай останется, но выполняться не
    будет:![](https://ucarecdn.com/30dbc5de-730f-4cf6-9469-d316dcb09b1b/){alt=""}

4.  `message = TRUE` --- выводить ли в печать сообщения от функций.
    Обычно это тоже не нужно;

5.  `warning = TRUE` --- большинство предупреждений выводятся только
    один раз, но не стоит включать их в статистический отчёт;

6.  `fig.width  = 7` и `fig.height = 7` --- размеры изображений в
    дюймах. Если не указано иное, стоит устанавливать нужные значения в
    каждом отдельном чанке после того, как эти значения будут подобраны
    опытным путём (они могут быть и дробными):

    ![](https://ucarecdn.com/28a5bad3-3fe9-4044-88f6-48ced54ed522/){alt=""}

## **Оглавление документа**

![](https://ucarecdn.com/55f6007e-c69d-49b4-9119-6c8723401179/){alt=""}

Если аккуратно расставлять заголовки (напомним, они делаются с помощью
знаков `#`), то открывается возможность сделать автоматическое
оглавление, которое будет собираться на основе этих заголовков разных
уровней.

Для этого используется параметр `toc: yes`. 

Дополнительно можно ограничить количество возможных уровней списков в
оглавлении с помощью соответствующего параметра. В примере количество
уровней ограничено тремя: `toc_depth: 3`.

Наконец, по умолчанию заголовок оглавления будет "Table of Contents", но
зачастую мы хотим изменить его. Для этого используется параметр
`toc-title: "Оглавление"` как в примере. Обратите внимание, что, в
отличие от остальных параметров, связанных с автоматическим оглавлением,
этот параметр пишется без отступов.

## **Печать файла в Word, html, pdf**

Нужно выбрать, в какие форматы печатается RMarkdown.

![](https://ucarecdn.com/b81000dd-7cb0-404e-b0d6-0d9c41b82b93/){alt=""}

Напечатать документ очень легко. Для этого надо на верхней панели нажать
на треугольник рядом
с ![](https://ucarecdn.com/df65c967-8498-404f-8043-76db55b43920/){alt=""},
после чего выбрать нужный формат из выпавшего списка. Для иных форматов
нужно вручную прописать формат вывода в заголовке файла.

Ниже выберите правильные варианты того, какие форматы доступны для
печати из RMarkdown. При необходимости попробуйте найти ответ с помощью
поиска в Интернете:

### **Референсный документ**

![](https://ucarecdn.com/eca2b0b9-5e94-4f19-9f14-f68eba3a1523/){alt=""}

Забавной особенностью печати в формат .docx является то, что для неё
доступен параметр референсного документа.

Этот документ --- просто документ .docx, но с установленными шрифтами
для текста, заголовков, таблиц, ориентации страниц, количества колонок
на каждой странице, одним словом, всего, что вообще возможно
отформатировать в Word. 

Если иметь такой файл (можно назвать его так, как на картинке выше и
переносить из проекта в проект), то достаточно положить его в ту же
папку, где находится и файл .Rproj. Остальное сделает сам генератор
документов: форматирование будет таким, какое мы ожидаем. 

Особенно удобно это, когда в нашем распоряжении находится образец
статистического отчёта, и нам нужно сделать такой же по формату, но
другой по наполнению.

# 3. Пакеты R

## 3.1 Работа с пакетами

**Что такое пакет?**

**Пакет R** --- это строгим образом организованный код, предоставляющий
дополнительные функции для выполнения самых разнообразных действий: от
статистических расчётов и печати отчётов до создания игр и простых
сайтов.

Например, в этом курсе мы в основном изучаем пакеты, представленные на
картинке ниже:

![[tidyverse.org](https://www.tidyverse.org/)](https://ucarecdn.com/5a20c7be-717f-446d-a992-db83331e7cf3/){alt=""}

Базовый список пакетов, которые по умолчанию загружаются вместе с R при
первой установке (всего 30): *base, compiler, datasets, grDevices,
graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools,
translations, utils, KernSmooth, MASS, Matrix, boot, class, cluster,
codetools, foreign, lattice, mgcv, nlme, nnet, rpart, spatial, and
survival*.

При должном старании и наличии времени с помощью только лишь этих
пакетов возможно осуществить большую часть видов статистического анализа
данных и даже создать отчёт, но с помощью *tidyverse* и *knitr* делать
это приятнее и удобнее.

Описание каждого пакета можно посмотреть в разделе DESCRIPTION.
Например, вот начало этого раздела (под названием) для пакета ggplot2:

![](https://ucarecdn.com/623f101c-d2e6-4462-a385-fdb7ea7008a3/){alt=""}

Также справку о пакете можно получить командой
`help(package = "package_name")`. Например, попробуем получить справку
по пакету ggplot2: 

![](https://ucarecdn.com/4e17f593-0b8b-42a5-bdac-523ebcc81fa7/){alt=""}

Если нужно вставить цитирование пакета, можно выполнить функцию
`citation("package_name")`. Процитируем для примера вновь тот же пакет
ggplot2:

![](https://ucarecdn.com/e81f0ffd-4681-4e22-a4ff-475124d3c945/){alt=""}

**Что такое репозиторий? Три основных репозитория для R**

Репозиторий --- это место хранения пакетов программ, дополнительно
оснащённый информацией, позволяющей понять, зачем нужен каждый данный
пакет. Дополнительно присутствует функционал установки и обновления
пакетов и часто даже гарантии того, что в пакете нет вирусов, а
работоспособность кода в пакетах проверена на различных системах и
машинах.

[**CRAN**](https://stepik.org/lesson/1403995/step/cran.r-project.org)
**(Comprehensive R Archive Network)**

Основной и центральный репозиторий, поддерживаемый R Foundation и
расположенный в Венском университете экономики и бизнеса и зеркалах по
всему миру. На данный момент он содержит более 17000 пакетов, каждый из
которых проверен вручную командой CRAN. 

[**Bioconductor**](https://stepik.org/lesson/1403995/step/www.bioconductor.org)

Специализированный для анализа геномных и прочих биологических данных
репозиторий.

[**github**](https://stepik.org/lesson/1403995/step/github.com)**и
прочие**

На самом деле это веб-сервис для совместной разработки программного
обеспечения, но именно поэтому на нём и выкладываются многие очень
полезные пакеты.

**Разница между пакетом и библиотекой**

Важно отличать эти понятия: в то время, когда пакет --- это особым
образом организованный код, библиотекой принято называть ту или те
директории, в которые эти пакеты "складируются" на компьютере для
последующего использования.

Библиотеки чаще всего создаются автоматически. Например, если на
компьютере установлено несколько разных версий R, скорее всего будет и
несколько библиотек.

Важно, чтобы у пользователя был доступ к изменению и чтению папки, иначе
пакеты не смогут быть установлены.

Посмотреть пути к библиотекам очень просто. Нужно выполнить функцию
`.libPaths()`:

![](https://ucarecdn.com/9582953f-9594-4608-87b3-808df1aa43ed/){alt=""}

В примере видно, что на компьютере есть только одна библиотека, путь к
которой и указан в выводе функции.

Разумеется, можно посмотреть и список пакетов, установленных в
библиотеке. Достаточно вызвать функцию `library()` без аргументов.
Проверим:

![](https://ucarecdn.com/137c2999-170f-466a-8f8e-ee8291727e39/){alt=""}

**Манипуляции с пакетами с CRAN**

[Устанавливать пакеты]{.underline} просто: 

1.  Если мы хотим установить один пакет, достаточно написать
    так: `install.packages("package_name")`;

2.  Но легко установить и сразу несколько пакетов, для чего нужно
    использовать синтаксис
    вектора: `install.packages(c("package_name", "package_name_2", "package_name_3"))`.

Проверка того, [какие пакеты установлены]{.underline}, проводится через
функцию `installed.packages()`, которая возвращает: имя пакета; путь к
библиотеке, где лежит пакет; версию пакета и зависимости:

![](https://ucarecdn.com/caa8d2ac-587a-4059-97a0-916e9d9350f3/){alt=""}

Иногда необходимо [удалить пакет]{.underline}, что можно сделать
функцией: `remove.packages("package_name")`. Часто это может
пригодиться, если внезапно пакет выдаёт ошибку после неудачного
обновления и нужно поставить его с нуля.

Вывод [списка устаревших пакетов]{.underline} производится
функцией `old.packages()`, которая выводит текущую версию пакета и самую
новую, которая содержится в подключённом репозитории, а также даёт
ссылку на этот репозиторий:

![](https://ucarecdn.com/983665fa-a129-4054-af9e-beecc756eea5/){alt=""}

После того, как мы узнали, какие пакеты устарели, может возникнуть
необходимость или желание обновить пакеты, что делается
функцией `update.packages("package_name")`.

 

**Манипуляции с пакетами через Bioconductor**

Прежде, чем устанавливать пакеты с Bioconductor, необходимо установить
функцию для установки: `source("https://bioconductor.org/biocLite.R")`.

```{r}
source ("https://bioconductor.org/biocLite.R")
```

После этого всё происходит аналогично стандартной функции. Например:
`biocLite("package_name")`.

**Манипуляции с пакетами через devtools**

Почти всегда установка пакетов с github нужно, чтобы предварительно были
установлены **RTools**, что мы сделали в самых первых шагах.

Основная функция установки пакетов с github:
`devtools::install_github("hadley/dplyr")`. В этом примере из
репозитория *hadley* (основной разработчик tidyverse) устанавливается
пакет *dplyr*.

Для расширения представления упомянем также функции: install_bioc(),
install_bitbucket(), install_cran(), install_git(), install_local(),
install_url(), install_version().

**Подключение пакетов**

[После того, как мы установили пакеты, жизненно необходимо подключать их
каждый раз, когда нам нужны функции из них. Это нужно делать каждый раз
при открытии новой сессии, иначе R не сможет понять, откуда что брать
для работы.]{.underline}

Существует две функции для подключения пакетов к текущему проекту.
Разберём их подробнее:

1.  `library(package_name)` (название пакета можно писать без кавычек)
    --- основная функция, которой стоит пользоваться всегда. Дело в том,
    что в случае, если пакет ещё не установлен, эта функция вернёт
    ошибку и прервёт выполнение кода. Таким образом мы не окажемся в
    ситуации, когда обнаружим отсутствие нужных функций уже тогда, когда
    напишем какой-то работающий частично код;

2.  `require(package_name)` --- эта функция возвращает `FALSE` вместо
    ошибки, что удобно, когда мы пишем сложные функции, зависящие от
    наличия возможности подключить пакет.

Но, если мы по какой-то причине не хотим явно подключать проект, можно
использовать функции напрямую из установленного пакета с помощью
синтаксиса `packagename::functionname()`. Например: `dplyr::select()`.

**Отключение пакета**

Кроме подключения пакетов иногда нужно их выключить. 

Это делается так: `detach(package:dplyr)`. В этом примере мы выгружаем
пакет *dplyr* и его функции становятся недоступны. Обратите внимание,
что внутри функции обязательно нужно писать `package:` (с двоеточием), а
потом название пакета без кавычек.

**Перекрытие имён пакетов**

В случае, если в разных пакетах функции называются одинаково, может
произойти перекрытие имён. В таком случае для использования будет
доступен только тот вариант функции, который был загружен последним. 

Самый знаменитый в узких кругах пример перекрытия --- это функция
`select()`:

![](https://ucarecdn.com/648802a3-7c15-4741-839b-9162b997f08b/){alt=""}

Исправить это можно двумя путями:

1.  Загрузить *dplyr* после *MASS*;

2.  Использовать синтаксис прямого обращения к функции без подключения
    всего пакета.

## 3.2 Разбор полезных пакетов

**tidyverse, объяснение философии tidyverse**

Язык **R** предназначен для работы с данными и статистической обработки
и, как мы уже знаем, даже его базовой версии достаточно для того, чтобы
выполнять анализ на приемлемом уровне. 

Однако, многие годы уже существует популярный "диалект" языка ---
система пакетов **tidyverse**. 

Эта система на самом деле набор пакетов для анализа данных, выполненная
в единой философии и придерживающиеся идеи, что любой анализ данных
состоит из единого алгоритма:

![ "R for Data Science" (Wickham and Grolemund
2017)](https://ucarecdn.com/1aaab4c3-6c53-43f5-9ab3-da703037074e/){alt=""}

1.  Первым шагом мы **импортируем данные**, для чего в экосистеме есть
    пакеты на любой вкус и для любых форматов данных: от файла txt до
    данных из SAS. Пакеты для этого шага: *readr, readxl, haven*;

2.  Вторым **приводим данные в порядок**, то есть, к аккуратной форме:
    каждая строка --- это одно наблюдение, а каждый столбец --- это одна
    переменная. Пакеты: *tidyr*;

3.  **Преобразование данных**. Этот шаг будет рассмотрен в курсе
    наиболее подробно, именно он наиболее близок к "автоматизации
    обработки данных". Пакеты: *dplyr*;

4.  **Визуализация данных**. Не всегда в отчёте нужны точные и строгие
    таблицы. Иногда нужны точные и строгие графики, изображения, чтобы
    показать данные наиболее доступно (и привлекательно). Пакеты:
    *ggplot2, ggpubr*;

5.  **Моделирование данных**. Этот шаг пока что выходит за рамки курса,
    но почти в каждой статье встречается модель, связывающая целевую
    переменную и те, что тесно связаны с изменениями её значений.
    Пакеты: *tidymodels*;

6.  **Коммуникация**. После того, как мы сделали все шаги выше, нужно
    рассказать о них, передать информацию уже не компьютеру, а людям. Мы
    уже изучили основной пакет: *rmarkdown*, но также есть и *Shiny*, и
    оба их можно изучить глубже;

7.  Но всё это стоит на одном ките: **программировании**. Для того,
    чтобы работать с данными и рассказывать о них, мы используем пакеты,
    которые облегчают написание функций и работу с кодом, который после
    преобразуется в понятные и выразительные отчёты. Пакеты: *purrr,
    tibble, reprex, magrittr*.

### **dplyr**

Этот пакет содержит в себе базовую грамматику манипулирования данными.
Именно на его основе строится львиная доля автоматизации обработки
данных. Основные его функции (глаголы, говорящие, что именно мы делаем):

1.  `mutate()` --- изменяет переменные, добавляет новые;

2.  `select()` --- выбирает переменные;

3.  `filter()` --- фильтрует объекты по условиям;

4.  `summarise()` --- вычисляет сводные статистики;

5.  `arrange()` --- сортирует по переменным;

6.  `group_by()` --- группирует по значениям переменных;

7.  `*_join()` --- группа глаголов для склеивания двух таблиц по ключу.

![Пример очистки данных с помощью глаголов
dplyr](https://ucarecdn.com/19854358-6275-4fa4-a7a8-e066472106b4/){alt=""}

### **tidyr**

Пакет для создания аккуратных данных.

Аккуратные данные --- это просто данные, в которых:

1.  Каждая строка --- это наблюдение;

2.  Каждый столбец --- это переменная;

3.  Каждая ячейка --- это единственное значение.

В случае, если наши данные представлены в аккуратном виде, обращение с
ними становится более простым --- не нужно тратить время на борьбу с
данными вместо анализа этих данных.

Пакет позволяет:

1.  Поворачивать данные, то есть, преобразовывать их в длинный и широкий
    форматы: `pivot_longer(), pivot_wider()`;

2.  Разворачивать данные из вложенных списков в простые таблицы:
    `unnest_longer(), unnest_wider()`;

3.  Наоборот, делать из таблиц вложенные переменные: `nest(), unnest()`;

4.  Разделять и объединять столбцы по разделителю строк:
    `separate(), unite()`;

5.  Заполнять отсутствующие значения определёнными значениями или
    удалять их: `complete(), drop_na(), fill(), replace_na()`.

![Пример заполнения пропущенных значений одним
определённым](https://ucarecdn.com/468e929c-7408-45c6-89c8-f286cf93ebed/){alt=""}

### **readr, readxl, haven**

Три основных пакета, которые помогают читать данные.

1.  **readr** предназначен для чтения самых распространённых форматов
    данных: *\*.csv, \*.txt, \*.tsv*;

2.  **redxl** помогает читать файлы *\*.xlsx* или, иными словами, всё,
    что пересылается в формате Excel;

3.  **haven** читает форматы *\*.sas7bdat, \*.sap, \*.dta, \*.sav,
    \*.por*, то есть данные из SAS.

### **purrr**

Этот пакет может поначалу казаться сложным для понимания, однако на
самом деле он просто расширяет функционал уже известного семейства
функций `*apply()`.

Функция `map()` и её расширения позволяют итерироваться по элементам
векторов или списков самыми разными способами. Без лишних слов приведём
здесь выдержку из официальной шпаргалки:

![](https://ucarecdn.com/c304bd37-5116-4007-8fa9-748995b3782a/){alt=""}

### **tibble**

В базовом R уже есть *data.frame*, однако *tibble* позволяет создавать
гораздо более приятные для работы таблицы данных.

1.  В отличие от *data.frame* он не приводит строки к факторам
    автоматически. Это нужно сделать самостоятельно, однако таким
    образом мы всегда в точности знаем, что находится в каждой
    переменной датафрейма;

2.  Имена переменных остаются такими же, какими были. Например, в
    переменной с названием "*variable name*" пробел не будет заменён на
    точку, вместо этого имя будет окружено апострофами (обычно находятся
    на букве "*ё*"), что сохраняет ожидания от названий;

3.  *tibble* оценивает переменные лениво. По существу, это значит, что
    при создании мы можем объявлять одну переменную на основе другой (но
    эта другая должна быть указана первой).

![Пример создания датафрейма через
*tibble*](https://ucarecdn.com/2f4baf51-1ddb-4c9d-bb58-f78402bfe1d3/){alt=""}

### **ggplot2 и ggpubr**

Для визуализации данных существует сразу два пакета: базовый *ggplot*,
содержащий в себе почти всю необходимую для создания графики
функциональность.

Дополнительные интересные особенности вроде автоматического расчёта и
добавления на график p-value, реализованы в пакете *ggpubr*.

![Пример создания информативного графика со сравнением
групп](https://ucarecdn.com/cb153053-b905-4593-9820-27831db6e0bf/){alt=""}

### **flextable**

Обычно мало просто сделать статистические таблицы в R. Необходимо ещё и
напечатать эти таблицы в виде, пригодном для восприятия коллегами без
лишних проблем. Именно для этого нужен пакет flextable, который мы
изучим в отдельном (последнем) модуле.

![Пример создания пригодной для печати статистической
таблицы](https://ucarecdn.com/d7d6a86d-50b0-40bb-82d1-adfc824d0078/){alt=""}

### **stringr**

Очень часто в данных есть строковые переменные, в которых записана некая
текстовая информация, важная нам для исследования. Например, в одной
ячейке записаны все возможные названия препарата, и стоит задача взять
только тех участников исследования, у которых название препарата
содержит подстроку "циклин".

![Пример поиска
подстроки](https://ucarecdn.com/4e590382-ca92-49dd-b8c6-e08b63120710/){alt=""}

### **lubridate**

Помимо строковых данных часто встречаются и даты. С ними нельзя работать
как с факторами, строками или, тем более, числами. Для этого существует
специальная библиотека, которая может даже вычислить разницу между двумя
датами с учётом високосных годов. 

![Пример "арифметики" с
датами](https://ucarecdn.com/d2aef8da-75bc-4dff-8140-ad182f038b51/){alt=""}

### **DescTools, psych**

Существуют пакеты, в которых собраны статистические функции, позволяющие
чуть ли не в одну строку подготовить базовый статистический отчёт.

В *DescTools* мы найдём полезные функции для статистических тестов и
доверительных интервалов, а в psych функции для корреляционных матриц и
расчёта сразу группы статистик.

![Расчёт пула статистик с помощью пакета
psych](https://ucarecdn.com/270a929f-66bd-4abe-a0ca-36e3757284cc/){alt=""}

# 4. Чтение данных

**Базовые способы чтения файлов**

Наконец, узнав всю теорию, мы переходим к овладению практическими
навыками.

Обратимся к [предыдущему
уроку](https://stepik.org/lesson/1403996/step/1?unit=1421330) и,
особенно, к схеме обработки данных. Первый шаг: импорт данных. В серии
последующих шагов мы разберём почти все существующие методы чтения
данных.

Начнём с базовых функций и форматов данных.

**Формат csv**

Большая часть данных поступает в обычном текстовом виде:

1.  *csv (comma-separated values):* предполагается, что строка текста
    --- это строка таблицы, которая разделена запятыми, в результате
    чего получаются\... столбцы. Разделитель десятичных знаков при этом
    --- точка. Однако, вопреки названию, разделителем может быть и точка
    с запятой (;), при этом разделитель десятичных знаков --- запятая;

2.  *tsv*: то же, что и выше, но разделителем является уже символ
    табуляции.

![Пример csv-файла данных, с которым мы будем
работать](https://ucarecdn.com/cf355fbe-b2a9-410f-8760-4646239d1c0d/){alt=""}

**read.\***

Для того, чтобы прочитать данные из файлов, существуют базовые функции,
доступные в R сразу после установки.

Несмотря на доступность этих функций, у них есть некоторые неудобные
особенности, которые решены в
[tibble](https://stepik.org/lesson/1403996/step/6?unit=1421330).

![Тот же файл, но уже прочитанный базовой
функцией](https://ucarecdn.com/787450d0-e94b-4087-83f6-4554a998c9ba/){alt=""}

Выше мы видим пример файла csv с разделителем-запятой. Обсудим
конкретно, какими функциями читается каждый формат:

1.  `read.csv()` читает csv с запятой в качестве разделителя;

2.  `read.csv2()` читает csv с точкой с запятой в качестве разделителя
    (кстати, этот же формат отлично читает Excel, сразу разбивая его на
    столбцы);

3.  `read.tsv()` читает csv со знаком табуляции в качестве разделителя
    (часто этот формат сохраняют в файле с расширением .txt).

Однако, в каждой функции при этом можно указать параметры `sep`,
`quote`, `dec`, которые, соответственно, устанавливают знаки:
разделителя, кавычек, десятичного разделителя. 

Дополнительно можно указать параметр `header`, который говорит функции,
является ли первая строка документа заголовком для каждого столбца или
нет.

**write.\***

Иногда необходимо выгрузить файл с данными.

Например, мы почистили данные, перекодировали их, после чего хотим
сохранить полученную таблицу для дальнейшего использования. Или мы можем
сделать сводную таблицу по определённым переменным, после чего показать
её коллегам.

Перечислим функции, необходимые для печати файлов:

1.  `write.csv()`, `write.csv2()` печатают датафрейм в файлы csv с
    соответствующими разделителями, но их использование (особенно на
    Windows) может приводить к забавной вещи --- поломке кодировки,
    когда символы в Excel не читаются человеком. Как решить эту
    проблему, мы узнаем в следующих шагах.

**readr::read_delim(), readr::write_delim()**

Теперь мы знаем базовые способы чтения файлов, доступные сразу после
установки R.

Однако, далее мы изучим способы более эффективного чтения файлов,
доступные уже после подключения
[tidyverse](https://stepik.org/lesson/1403996/step/1?unit=1421330).
Основных пакетов два: **readr** и **readxl**, но есть ещё и **haven**.
Пакеты будем указывать перед функциями, обращайте на них особое
внимание. 

**Помните**: результаты чтения данных нужно присваивать переменной,
чтобы с ними позже можно было работать.

Прежде всего рассмотрим наиболее общую функцию, которая позволяет читать
файлы форматов csv и tsv.

> **read_delim("data/raw/data_csv.csv", delim = NULL, quote = "\\", na =
> c("","NA"), skip = 0, n_max = Inf, col_names = TRUE)**

Прежде всего рассмотрим сообщение, которое возвращает эта функция.
Базовые функции не делают этого, но для анализа данных это зачастую
очень полезно.

![Дополнительная информация при чтении
данных](https://ucarecdn.com/c1ac26bc-e615-4657-8a75-182c4805a9e5/){alt=""}

Обратим внимание, что в данном вызове функции мы указали, что нужно
читать максимум 10 строк --- от 1 до 10.

Функция говорит нам, сколько в прочитанных данных строк (rows), столбцов
(columns), после чего явно показывает, какой в данных разделитель
столбцов (в данной функции мы указываем его самостоятельно).

В итоге мы можем увидеть типы переменных. Как можно заметить, функции из
tidyverse не приводят типы при чтении самостоятельно: если переменная
строковая, она и будет строковой до тех пор, пока мы явно не укажем, что
она должна быть факторной.

**Осторожно**: переменные могут становиться строковыми по самым
удивительным причинам. Одна из самых распространённых: во всех ячейках
использован разделитель-точка, и только в одной ячейке --- запятая.
Такое приходится исправлять вручную.

**readr::write_delim()**

> write_delim("data/raw/data_csv.csv", delim = ",", na = "NA")

Простая функция, позволяющая записать файл в необходимый нам формат с
указанными разделителями.

**Задание**

Прочитайте файл по
[ссылке](https://stepik.org/media/attachments/course/122402/data_tsv.tsv) в
RStudio на своём компьютере
~(если нажать на гиперссылку, то файл скачается в "Загрузки", если ваша операционная система --- Windows)~.
Правильно ответьте на два простых вопроса.

```{r}
data <- read_delim(file = "E:/Bioinform/Sahsa/data_tsv.tsv")

```

**readr::read_csv(), readr::read_csv2()**

Теперь будет совсем просто, ведь эти функции всего лишь частные случаи
изученной нами на [прошлом
шаге](https://stepik.org/lesson/1403997/step/3?unit=1421331).

> read_csv("data/raw/data_csv.csv", skip = 0, n_max = Inf)
> #разделитель-запятая

![Пример чтения csv-файла с
разделителем-запятой](https://ucarecdn.com/f854a17a-2bbc-44ca-9764-e403b0dfedfa/){alt=""}

Как можно легко заметить, эта функция --- просто легко читаемый и
запоминаемый вариант предыдущей, где указание разделителя уже
присутствует по умолчанию.

> read_csv2("data/raw/data_csv2.csv", skip = 0, n_max = Inf)
> #разделитель-точка с запятой

![Пример чтения csv-файла с разделителем-точкой с
запятой](https://ucarecdn.com/b08f4047-7333-4c81-a62f-c5f0d63f9d7c/){alt=""}

Чтобы потренироваться в чтении файлов, вы можете попробовать прочитать
[файл с
запятой](https://stepik.org/media/attachments/lesson/790857/data_csv.csv),
а потом [файл с точкой с
запятой](https://stepik.org/media/attachments/lesson/790857/data_csv2.csv).

**readr::write_csv(), readr::write_csv2(), readr::write_excel_csv(),
readr::write_excel_csv2()**

Точно так же легко и записываются файлы с соответствующим разделителем.

Внимательный читатель увидит, что здесь уже четыре функции, две из
которых отличаются от своих близнецов только дополнением "excel". Дело в
том, что функции с дополнением "excel" позволяют меньше опасаться, что
при открытии файлов в Excel вместо кириллических (чаще) или иных
символов (реже) пользователь увидит нечитаемый набор символов из-за сбоя
кодировки.

Последовательно рассмотрим примеры того, как писать эти функции.
Предположим, мы сохранили датафрейм в переменную `data`.

> write_csv(data, "data/raw/data_csv.csv")

> write_excel_csv(data, "data/raw/data_csv.csv")

> write_csv2(data, "data/raw/data_csv2.csv")

> write_excel_csv2(data, "data/raw/data_csv2.csv")

**readr::read_tsv()**

> read_tsv("data/raw/data_tsv.tsv", skip = 0, n_max = Inf)

![Пример чтения файла с
разделителем-табуляцией](https://ucarecdn.com/5c8947ac-9d0f-47ae-91b0-af247c834914/){alt=""}

Ещё одна вариация исходной функции. Учитывая приобретённый опыт,
дальнейшие объяснения не требуются. Чтобы потренироваться, скачайте
[файл с табуляцией в качестве
разделителя](https://stepik.org/media/attachments/lesson/790857/data_tsv.tsv).

**readr::write_tsv()**

> write_tsv("data/raw/data_tsv.tsv")

**readxl::read_excel()**

Часто данные поступают нам не просто в текстовом формате с разными
разделителями.

Иногда их присылают в формате книги Excel, да ещё и на нескольких
листах.

Посмотрим, что с этим можно сделать. Будем использовать [файл по
ссылке](https://stepik.org/media/attachments/lesson/790857/data_excel.xlsx),
но сначала стоит отметить одну неочевидную вещь.

> Excel часто ломает даты, переводя их в дробные числа, а дробные числа
> в даты.

Если вы ожидаете, что в данных будут даты, перепроверьте это отдельно.
Иначе может получиться, что гемоглобин у вашего пациента --- *пятое
мая*.

![Файл в формате xls/xlsx, открытый в
Excel](https://ucarecdn.com/7be199fc-7b45-4886-9ea9-ef009e2efd9b/){alt=""}

Обратим внимание на структуру. В этом примере у нас один лист, и часто
так и бывает. Но может быть два и более листов. Именно для этого нужно
указывать соответствующий аргумент. Если не указать, то по умолчанию
будет прочитан просто первый лист.

> read_excel("data/raw/data_excel.xlsx", sheet = "data")

![Результат чтения файла
xlsx](https://ucarecdn.com/12ab5f42-73a8-4bc6-aea6-8168cf3036bc/){alt=""}

Эта функция не выдаёт дополнительную информацию, вместо этого она сразу
читает соответствующий лист. 

**xlsx::write.xlsx()**

Существует несколько пакетов, позволяющих записывать данные в книги
Excel: xlsx, openxlsx, writexl. Однако, здесь мы будем использовать
openxlsx, поскольку он не требует установки Java и наиболее просто
устанавливается почти на всех компьютерах.

> write.xlsx(data, "data_excel.xlsx", colNames = TRUE)

Вот и всё. У нас появляется файл Excel с записанными данными. Перейдём к
бонусу для тех, у кого установлен Java.

**openxlsx::write.xlsx(), openxlsx::write.xlsx2()**

Прежде всего отметим, что дублирующая функция с цифрой 2 используется
преимущественно для того, чтобы быстро записывать крайне большие
датафреймы (более, чем 100 тысяч ячеек).

> write.xlsx(data, "data_excel.xlsx", sheetName = "data", col.names =
> TRUE, row.names = TRUE, append = FALSE)

Функция создаёт книгу Excel, а в ней лист с соответствующим именем.
Аргументы `col.names` и `row.names` говорят, нужно ли записывать в файл
имена столбцов и имена строк соответственно. Аргумент `append`нужен для
того, чтобы\...

> write.xlsx(data, "data_excel.xlsx", sheetName = "data_2", col.names =
> TRUE, row.names = TRUE, append = TRUE)

\...добавлять новые листы к уже существующей книге. 

**haven::read_spss(), haven::read_sas()**

Очень редко, но приходится читать данные, которые выгружены напрямую из
SPSS или SAS.

**haven::write_sav()**

Точно так же можно записать данные, чтобы наш предполагаемый коллега мог
загрузить их в SPSS.

Это самый короткий шаг во всём курсе, поэтому проследуем дальше.

**readr::read_rds()**

Работать с форматом csv приятно и легко (чаще всего): он занимает мало
места, переносится между большинством платформ и не изменяет данные без
нашего ведома.

Однако, есть формат, который правит всеми в среде R. Это rds. Его
особенность в том, что он просто сериализует (переводит в некий общий
набор байт) нужный объект. Если это таблица, которую мы, разумеется,
предварительно почистили и привели все переменные к нужным типам (а
основных типов в базовом случае два: количественный и факторный), то
сохранение в формат rds сохраняет и типы. 

Как бонус, в этот формат можно сохранять буквально что угодно: модели,
списки, переменные. И потом восстановить это в первозданном виде. 

В случае, если нет нужды передавать таблицы другим людям, которые не
работают в R, разумно будет сохранять свои промежуточные данные именно в
этот формат.

> read_rds("data/raw/data.rds")

![Чтение предварительно сохранённых данных из формата
rds](https://ucarecdn.com/b435fe12-937e-41c2-b391-c843fdc35a7b/){alt=""}

Обратите внимание, что факторные переменные действительно имеют тип
factor, в то время как в предыдущих вариантах они читались как
строковые.

**readr::write_rds()**

> write_rds(data, "data/raw/data.rds")

Именно так данные записываются в формате rds.

# 5. Расчёт базовых статистик

## 5.1 Базовые статитсики

### **mean()**

Большая часть статистических функций встроены в R по умолчанию. Это
хорошая новость для нас: при должных усилиях мы сможем провести
статистический анализ, вообще не устанавливая ничего, кроме базового R.

Первая функция, с которой мы познакомимся: это
`mean(x, trim = 0, na.rm = FALSE)`.

> `> mean(c(20, 68, 45, 76, 41, 36, 13, 52, 77, 53, 70, 73))[1] 52`

Аргументы у функции следующие:

1.  `x`: вектор типа *numeric*;

2.  `trim = 0`: аргумент, говорящий, сколько процентов наибольших и
    наименьших значений нужно убрать перед тем, как вычислять среднее.
    Позволяет избавиться от выбросов;

3.  `na.rm = FALSE`: если мы предполагаем, что в векторе могут
    встретиться пропущенные значения, то необходимо установить значение
    этого аргумента как `TRUE`, в ином случае результатом функции будет
    *NA*.

*Среднее арифметическое* --- это один из вариантов среднего значения:
сумма всех элементов вектора, делённое на количество этих элементов.
Обратим внимание, что рассматриваемая функция вычисляет именно
*выборочное среднее*. Эта характеристика распределения имеет проблему:
на неё сильно влияют выбросы.

```{r mean()}

mean(c(1, -1, 5, -12, -12, 3, 8, -10, 0), trim = 0, na.rm = TRUE)
mean(c(-2, 16, -3, 16, -9, 7, 31), trim = 0, na.rm = TRUE)
mean(c(-13, 19, -24, NA, 30, 64, -53, NA, 50, 31, -58, -34, -3, -34, 77), trim = 0, na.rm = TRUE)
mean(c(NA, NA, NA, NA, NA, NA, 3, NA, NA), trim = 0, na.rm = TRUE)
mean(c(-19, -9, 19, 5, -14, 0, 34, -8, 34, 24, -11, 8, 33, 12, -6), trim = 0, na.rm = TRUE)
mean(c(76, 65, 71, 16, 60, 29, 71, 46, 45, 41), trim = 0, na.rm = TRUE)
```

### **median()**

Более надёжная оценка --- медиана:`median(x, na.rm = FALSE)`.

> `> median(c(30, 87, 55, -71, 93, 50, 34, -51, 13, 96, -62, 53, -85))[1] 34`

Аргументы у функции следующие:

1.  `x`: вектор типа *numeric*;

2.  `na.rm = FALSE`: если мы предполагаем, что в векторе могут
    встретиться пропущенные значения, то необходимо установить значение
    этого аргумента как `TRUE`, в ином случае результатом функции будет
    *NA*.

*Медиана --- это значение, меньше которого 50% значений. В случае, если
количество элементов вектора чётное, медианой становится среднее
значение двух "средних" элементов.*

1.  

Сопоставьте вектора и их медианы:

```{r median }

median(c(19, 89, 78, 38, 8, 17, 25, 60, 8, 43, 29, 6, 62, 41, 69, 97, 61, 83, 25, 24), na.rm = TRUE)
median(c(-15, 71, 77, 36, 66, -21, -48, -8), na.rm = TRUE)
median(c(1, 9, NA, 88, 2, NA, 42, NA, 4, 68, NA), na.rm = TRUE)
median(c(-92, -50, 54, 55, 84, 52, -55, -23, 36, -11, 22, 11, -7), na.rm = TRUE)
median(c(-91, -33, 13, 34, 34, 75, -80, -35, -90, -72, 70, 67, -100, -94, -18), na.rm = TRUE)
```

### **min(), max()**

Две простые функции, которые просто вычисляют минимальное значение и
максимальное значение для вектора чисел.

> `min(x, na.rm = FALSE)`
>
> `max(x, na.rm = FALSE)`

Пример работы функций:

> `min(c(13, 50, 44, 37, 20, 29, -8, 4, 45, 31, 47, -5, -2, 24, 17, 45, 44, 31, -5, 26))`
>
> `[1] -8`

> `max(c(13, 50, 44, 37, 20, 29, -8, 4, 45, 31, 47, -5, -2, 24, 17, 45, 44, 31, -5, 26))`
>
> `[1] 50`

Сопоставьте вектора и их минимумы и максимумы (первое число --- минимум,
второе число --- максимум):

```{r min-max}

min(c(60.22, 31.91, 72.71, 52.49, 46.21, 60.39, 60.09), na.rm = TRUE)
min(c(48.11, 45.3, 58.42, 51.64, 62.07, 57.26, 49.69, 93.29, 81.18, 44.78, 55.1, 76.74, 58.08), na.rm = TRUE)
min(c(17.24, 35.77, 57.57, 30.15, 43.27, 77.56, 72.19, 40.45, 46.2, 39.92), na.rm = TRUE)
min(c(90.48, 31.16, 44.4, 21.94, 84.37, 53.15, 81.15, 47.86, 63.23, 46.75, 102.73), na.rm = TRUE)


max(c(60.22, 31.91, 72.71, 52.49, 46.21, 60.39, 60.09), na.rm = TRUE)
max(c(48.11, 45.3, 58.42, 51.64, 62.07, 57.26, 49.69, 93.29, 81.18, 44.78, 55.1, 76.74, 58.08), na.rm = TRUE)
max(c(17.24, 35.77, 57.57, 30.15, 43.27, 77.56, 72.19, 40.45, 46.2, 39.92), na.rm = TRUE)
max(c(90.48, 31.16, 44.4, 21.94, 84.37, 53.15, 81.15, 47.86, 63.23, 46.75, 102.73), na.rm = TRUE)
```

### **quantile()**

Представим, что у нас есть вектор из чисел. Мы упорядочиваем его по
возрастанию и теперь можем находить в нём такие числа, меньше или равен
которым определённый процент других чисел. Это и есть квантили.
Например, [медиана](https://stepik.org/edit-lesson/790858/step/4) ---
это просто 50% квантиль.

> quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type
> = 7)

1.  `x`: это исходный вектор с числами;

2.  `probs = seq(0, 1, 0.25)`: вектор процентилей, то есть, сколько
    процентов элементов вектора должно быть меньше или равно искомого
    числа;

3.  `na.rm = FALSE`: убирать ли пропущенные значения;

4.  `names = TRUE`: прикреплять ли имена квантилей к значениям
    полученного вектора;

5.  `type = 7`: есть несколько способов расчёта квантилей, но в общем
    случае можно использовать значение по умолчанию.

Обратим внимание на то, что эта функция может возвращать и конкретный
квантиль, например, 95%.

> `> quantile(c(31.83, 45.12, 55.66, 67.76, 25.73, 42.87, 55.22, 44.92, 48.03, 41.37, 66.26, 114.02, 32.93))    0%    25%    50%    75%   100%  25.73  41.37  45.12  55.66 114.02`

И вновь задача на сопоставление: сопоставьте вектора и их квантили.
Чтобы разнообразить процесс изучения материала, квантилей будет разное
количество.

```{r quantile()}
# quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7)

quantile(c(80.94, 44.46, 46.33, 65.1, 66.42, 104.43, 53.15, 48.41, 12.88, 51.1, 43.03, 40.3, 33.71, 55.1, 22.17), probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7) #все квартили

quantile(c(26.17, 97.73, 24.81, 53.62, 87.72, 45.19, 45.7, 69.63, 36.76, 7.17), probs = 0.5, na.rm = FALSE, names = TRUE, type = 7) 
# только 1 квартиль 50% - медиана
quantile(c(63.92, 35.85, 26.9, 48.92, 43.1, 66.94, 47.06, 56.54, 29.1, 58.88), probs = c(0.025, 0.975), na.rm = FALSE, names = TRUE, type = 7) # 2.5% b 97.5 квартили
quantile(c(32.05, 93.85, 85.52, 56.69, 23.69, 11.29, 51.44, 63.09, 65.65, 35.73, 60.15, 30.93, -4.2), probs = c(0.05, 0.95), na.rm = FALSE, names = TRUE, type = 7) # 5% b 95 квартили

```

### **var(), sd()**

Для того, чтобы понять, насколько вариативны наши данные относительно
среднего значения, мы можем рассчитать дисперсию и стандартное
отклонение. 

*Дисперсия* --- это просто средний квадрат отклонений значений от
среднего значения.

*Стандартное отклонение* --- это квадратный корень из дисперсии, который
измеряет отклонения в единицах переменной, а не в их квадратах.

Стоит знать, что существует смещённая оценка дисперсии и несмещённая, и
рассматриваемая функция вычисляет именно вторую.

> `var(x, na.rm = TRUE)`

1.  `x`: это исходный вектор с числами;

2.  `na.rm = FALSE`: убирать ли пропущенные значения.

> `> var(c(65.14, 49.87, 34.11, 43.23, 35.72, 35.73, 70.86))[1] 222.7726> sd(c(65.14, 49.87, 34.11, 43.23, 35.72, 35.73, 70.86))[1] 14.92557`

Сопоставьте вектора и оценки их дисперсии (первое число) и стандартного
отклонения (второе число):

```{r var_sd}
# var(x, na.rm = TRUE)
var(c(47.44, 62.44, 20.44, 72.75, 77.86, 13.74, 28.2, 50.47, 59.19, 69.04), na.rm = TRUE)
var(c(49.31, 44.47, 14.04, 44.43, 49.18, 40.73, 44.65, 41.91, 80.38, 80.09), na.rm = TRUE)
var(c(57.96, 20.81, 8.92, 14.03, 61.02, 25.69, 21.22, 49.56, 25.64, 28.31), na.rm = TRUE)
var(c(76.22, 65, 19.69, 29.84, 37.18, 70.93, 64.78, 61.66, 49.03, 51.56), na.rm = TRUE)
var(c(92.11, 56, 47.89, 62.96, 47.41, 37.05, 73.96, 53, 52.37, 85.23), na.rm = TRUE)

```

### **IQR()**

Межквартильный интервал позволяет оценить изменчивость данных, меньше
завися от выбросов. На самом деле его можно рассчитать, просто вычтя из
0.75 квантиля 0.25-й, однако в R существует и базовая функция.

> `IQR(x, na.rm = FALSE, type = 7)`

1.  `x`: это исходный вектор с числами;

2.  `na.rm = FALSE`: убирать ли пропущенные значения;

3.  `type = 7`: так как эта функция вычисляется на основе квантилей, для
    неё тоже применим тип квантиля, однако чаще всего подходит значение
    по умолчанию.

Сопоставьте вектора их их межквартильные интервалы:

```{r IQR}

# IQR(x, na.rm = FALSE, type = 7)
IQR(c(80.94, 44.46, 46.33, 65.1, 66.42, 104.43, 53.15, 48.41, 12.88, 51.1, 43.03, 40.3, 33.71, 55.1, 22.17), na.rm = TRUE, type = 7)
IQR(c(26.17, 97.73, 24.81, 53.62, 87.72, 45.19, 45.7, 69.63, 36.76, 7.17), na.rm = TRUE, type = 7)
IQR(c(63.92, 35.85, 26.9, 48.92, 43.1, 66.94, 47.06, 56.54, 29.1, 58.88), na.rm = TRUE, type = 7)
IQR(c(32.05, 93.85, 85.52, 56.69, 23.69, 11.29, 51.44, 63.09, 65.65, 35.73, 60.15, 30.93, -4.2), na.rm = TRUE, type = 7)
```

### **length()**

Простейшая функция, которая позволяет вычислять количество значений
вектора.

> `> length(1:10)[1] 10`

Приведём лайфхак, косвенно связанный с количеством значений вектора. 

Зачастую в работе нам нужно включить в таблицы количество значений без
пропущенных значений и количество именно пропущенных значений:

1.  `sum(!is.na(vec))`: количество значений без учёта пропущенных;

2.  `sum(is.na(vec))`: количество пропущенных значений.

```{r length}
vec <- c(1.2, 2, 4, 6, 7, 3, 1, 2, 4, 5, 3.66, NA, 65, 11, 32.25,NA )
length(vec)
sum(!is.na(vec)) #количество значений без учёта пропущенных;
sum(is.na(vec)) #количество пропущенных значений.
```

### **Стандартная ошибка среднего sd(x)/sqrt(length(x))**

Стандартная ошибка среднего --- это стандартное отклонение всех средних
выборки. 

Для неё нет базовой функции, однако мы можем написать её. 

Нужно просто разделить стандартное отклонение на квадрат длины вектора.
Разумеется, всё это без учёта пропущенных значений.

Сопоставьте вектора и их стандартные ошибки среднего:

```{r SE}

SE <- function(x) sd(x, na.rm = TRUE)/sqrt(length(x)) # задана функция нахождения Стандартной ошибки среднего
SE(c(47.44, 62.44, 20.44, 72.75, 77.86, 13.74, 28.2, 50.47, 59.19, 69.04))
SE(c(49.31, 44.47, 14.04, 44.43, 49.18, 40.73, 44.65, 41.91, 80.38, 80.09))
SE(c(57.96, 20.81, 8.92, 14.03, 61.02, 25.69, 21.22, 49.56, 25.64, 28.31))
SE(c(76.22, 65, 19.69, 29.84, 37.18, 70.93, 64.78, 61.66, 49.03, 51.56))
SE(c(92.11, 56, 47.89, 62.96, 47.41, 37.05, 73.96, 53, 52.37, 85.23))

```

# 6. Работа С Датафреймами с помощью пакетов dplyr, tibble и др.

## 6.1 tibble вместо data.frame как формат данных

### пайп %\>%

**%\>%**

Прежде чем продолжать, ознакомимся с краеугольным камнем подхода к
анализу данных, который будем использовать в дальнейшем.

[**Это пайп (%\>%).**]{.underline}

Его можно увидеть во многих мануалах и видео, но именно в этом уроке мы
поймём, что это такое.

Если кратко: это конвейер. Эта функция берёт результат работы функции и
передаёт его на вход в следующую функцию.

![Пример типичной цепочки преобразований
данных](https://ucarecdn.com/8963353e-9520-4c99-b4ca-7a714369cdef/){alt=""}

Цепочки из пайпов позволяют не переприсваивать данные, а писать точно
выполнимые (иначе выйдет ошибка) функции: от исходных данных до того,
что мы хотим получить. Например, статистическую таблицу с описательной
статистикой и сравнением групп.

Посмотрим на картинку. 

1.  Сначала у нас есть **data** --- наши исходные данные, мы уже
    работали с ними в модуле чтения данных (проверьте, что они всё ещё
    есть);

2.  С помощью пайпа мы передаём эти данные на место точки в функцию
    `select()` и с помощью остальных аргументов выбираем нужные
    переменные. У нас получится отфильтрованная по переменным таблица;

3.  Её мы подаём с помощью пайпа\... снова на место точки и фильтруем по
    значению определённой переменной. Остаются только участники из
    Группы 1;

4.  И вновь мы подаём пайпом получившиеся на прошлом шаге данные на вход
    переменной на место точки, после чего выбираем первые 10 строк;

5.  И вновь пайп\...

6.  Так происходит до тех пор, пока мы достигнем своих целей.

### **tibble()**

Мы знакомы со встроенной структурой данных data.frame (кстати, на самом
деле это просто несколько обязательно равных по длине векторов). 

![Структура
data.frame](https://ucarecdn.com/2a5fd9f2-2223-42be-a525-01b487ae77a4/){alt=""}

Оставим их в покое и перейдём к улучшенному варианту --- tibble.

Для того, чтобы получить возможность создавать их, необходимо подключить
пакет tibble: `library(tibble)`.

Особенности tibble:

-   tibble не изменяют тип ввода. Если вы вводили переменные типа
    character, то такими они и будут. Если numeric, то будут numeric. В
    том числе это позволяет даже вводить в качестве значений ячеек
    списки!

-   tibble не меняет имена переменных: если вы ввели имя с пробелом, то
    он не будет заполнен точкой или иным знаком, однако, нужно
    оборачивать имена в апострофы (чаще всего находится на клавише буквы
    "ё" в верхнем левом углу клавиатуры). Это следует делать всякий раз,
    когда имя переменной отличается от простой строки на латинице без
    иных знаков. Например: *columnname* не требует апострофов, а
    *\`column name\`* уже требует;

-   Оценивает аргументы лениво и последовательно, что мы разберём в
    следующем шаге;

-   Не использует имена строк;

-   При выводе таблицы данных в печать автоматически будут показаны
    только первые 10 строк и все столбцы, которые поместятся на экран.
    Благодаря этому даже очень большой датафрейм не заставит наш
    компьютер зависнуть.

При этом, к переменным tibble можно обращаться точно так же, как и к
обычному data.frame. 

![Примеры обращения к
переменной](https://ucarecdn.com/74be9f14-58e8-4378-9799-0bbe740d1806/){alt=""}

> *Заметка*: чтобы превратить data.frame в tibble, достаточно просто
> применить функцию `as_tibble()`.

> Заметка 2: имена в таблицах данных должны быть уникальны.

#### **Ленивая оценка аргументов**

Важная идея tibble, о которой мы упомянули на прошлом шаге:

> Ленивая оценка аргументов --- возможность создавать переменные на
> основе уже существующих.

![Создание tibble с использованием ленивой
оценки](https://ucarecdn.com/cfda720f-042f-4222-bb01-d59422b71395/){alt=""}

На картинке показано именно то, что мы узнали выше. Первая переменная
--- это цифры от 1 до 10 (кстати, именно так выглядит создание подобного
вектора --- от первого числа до последнего из указанных). Вторая
переменная создаётся на основе уже существующей с помощью возведения в
квадрат каждого значения предыдущей. 

Можно применять и более сложные функции:

![Создание второй переменной с помощью
условия](https://ucarecdn.com/975ca8be-42ae-4959-b7e2-b8d59d927d59/){alt=""}

> Обратите внимание! Создавать переменные можно только на основе тех,
> которые были определены ДО них, но никак не после.

```{r}



tibble(var = 1:10, var = var - 10000000)

tibble(var_first = 1:10, var_first = ifelse(var_first < 5, var_first + 100, var_first))

tibble(`var 1` = 1:10, `var 2` = `var 1` * 100)

tibble(var_1 = c(1:10) - 100, var_2 = 1:100)

tibble(var_first = 1:10, var_second = ifelse(var_first < 5, var_first + 100, var_first))

tibble(`var 2` = 10:1, `var 3` = `var 1` - 10)
```

### **View()**

Очень редко, но нам может понадобиться изучить таблицу данных
собственными глазами. 

Для этого пригождается функция `View()` (именно так, с большой буквы).

![Пример
функции](https://ucarecdn.com/ec4d0b8c-6860-4afa-8970-bdf833d014de/){alt=""}

Таблица будет выведена в новом окне, а не под чанком.

![Таблица
данных](https://ucarecdn.com/1527efb1-f560-4304-8fc0-063f0fbb5192/){alt=""}

В левом нижнем углу показывается текущее местоположение кадра данных. 

При нажатии на Filter (левый верхний угол) под каждой переменной
появится кнопка, где будет написано "all". В случае, если нажать на неё
у количественной переменной, будет показана гистограмма переменной, где
можно изменять максимум и минимум диапазона чисел, которые нужны.

![Фильтрация по количественной
переменной](https://ucarecdn.com/70167a46-da9b-40d3-ba0e-204d1a63fe28/){alt=""}

У категориальной переменной просто будут выведены категории, по которым
мы и сможем фильтровать датасет.

![Фильтрация по категориальной
переменной](https://ucarecdn.com/34b6844c-d5fa-4129-97d5-efb520fa25fe/){alt=""}

```{r View}
data %>% View()
```

### **tibble::add_column()**

Эта функция помогает просто добавить столбец с заранее заданными
значениями. Обратите внимание: его имя всё ещё должно быть уникальным.

> data %\>% add_column(column_name = 1:10, .before = NULL, .after =
> NULL)

-   `data`: просто имя датафрейма, к которому мы хотим добавить столбец;

-   `column_name`: это имя нового столбца. Оно может быть любым, не
    только таким, как в примере;

-   `.before`: номер уже существующего столбца, перед которым нужно
    поставить новый;

-   `.after`: то же, но уже после которого нужно поставить новый. Хитрый
    приём: если нужно поставить переменную в конец датафрейма, то в
    значение можно поставить *Inf*.

![Добавление новой
переменной](https://ucarecdn.com/4b1e3c3a-031c-4a31-8814-c80930250706/){alt=""}

### **tibble::add_row()**

Эта работает так же, как и прошлая, но добавляет строку, а, кроме того,
работа с ней существенно более неудобная, потому что нужно вручную
задавать имена и значения для каждой переменной.

> data %\>% add_row(var_1 = 1, var_2 = "value", .before = NULL, .after =
> NULL)

-   `data`: просто имя датафрейма, к которому мы хотим добавить СТРОКУ;

-   `var_1, var_2`: это имя нового столбца. Оно может быть любым, не
    только таким, как в примере;

-   `.before`: номер уже существующей строки, перед которым нужно
    поставить новый;

-   `.after`: то же, но уже после которого нужно поставить новый. Хитрый
    приём: если нужно поставить переменную в низ датафрейма, то в
    значение можно поставить *Inf*

![Добавление
строки](https://ucarecdn.com/ae21fb60-1fe4-4099-844f-52e64f9db933/){alt=""}

Обратим внимание, что в тех переменных, которые мы не указали явно,
автоматически добавились пропущенные значения.

Переменная "Группа" раньше была фактором, но мы добавили к ней новое
значение. С факторном переменной так делать нельзя, поэтому функция
автоматически привела тип к строковому, следует помнить эту
особенность. 

### **dplyr::row_number()**

Одна полезная функция, которая даёт возможность пронумеровать строки
(добровольцев).

![Добавление переменной
номера](https://ucarecdn.com/0a872c65-3e29-4f1b-b399-45ecb348847a/){alt=""}

### **dplyr::bind_cols()**

Мы можем сделать из двух и более таблиц одну, склеив их столбцы.

> data_1 %\>% bind_cols(data_2) %\>% bind_cols(data_3)

Именно так мы можем сделать это. Обратите внимание: в таблицах должно
быть одинаковое количество строк, а переменные должны иметь разные
имена. В ином случае будет возвращена ошибка.

![Склеивание трёх датафреймов одного за
другим](https://ucarecdn.com/ab94eda8-5b40-4c3d-95ac-47f96f403674/){alt=""}

```{r dplyr::bind_cols}
data1 <- tibble(var_1 = 1:10, var_2 = rep(c("гру 1", "гру 2"), 5))
data2 <- tibble(var_1 = rbeta(10, 1, 5), var_3 = rep(c("fkf1", "flf2"), 5))
a <- data1 %>% bind_cols(data2)
```
